{
  "initStatus": true,
  "recentFiles": [
    {
      "fileName": "建模任务 (1).km",
      "path": "C:\\Users\\Administrator\\Downloads\\建模任务 (1).km"
    },
    {
      "fileName": "建模任务.km",
      "path": "C:\\Users\\Administrator\\Downloads\\建模任务.km"
    },
    {
      "fileName": "建模任务 (2).km",
      "path": "C:\\Users\\Administrator\\Downloads\\建模任务 (2).km"
    },
    {
      "fileName": "button.json",
      "path": "C:\\Users\\Administrator\\Downloads\\button.json"
    },
    {
      "fileName": "建模任务3.km",
      "path": "C:\\Users\\Administrator\\Downloads\\建模任务3.km"
    },
    {
      "fileName": "建模任务4.km",
      "path": "C:\\Users\\Administrator\\Downloads\\建模任务4.km"
    },
    {
      "fileName": "建模任务5.km",
      "path": "C:\\Users\\Administrator\\Downloads\\建模任务5.km"
    },
    {
      "fileName": "建模任务5.md",
      "path": "C:\\Users\\Administrator\\Downloads\\建模任务5.md"
    },
    {
      "fileName": "思维导图.km",
      "path": "C:\\Users\\13194\\Documents\\思维导图.km"
    }
  ],
  "workspace": {
    "path": "C:\\Users\\13194\\Documents\\思维导图.km",
    "fileName": "思维导图.km",
    "data": "{\"root\":{\"data\":{\"id\":\"c17tsgo7etc0\",\"created\":1583911566920,\"text\":\"财务课程\",\"expandState\":\"expand\",\"note\":\"- 出现错误，尝试修改react和react native版本\\n- 首次使用白屏卡死，打开设置，应用程序，权限管理\\n- react-native run-android\\n- debug产生跨域问题，由于使用ip:8081/debugger-ui/进行访问，修改为：localhost:8081/debugger-ui/\\n- UI库：\\n  - https://react-native-training.github.io/react-native-elements/docs/0.19.0/overview.html\\n  - https://github.com/wix/react-native-ui-lib\\n  - https://github.com/rilyu/teaset\\n  \\n- style： \\n      export default class LotsOfStyles extends Component {\\n        render() {\\n          return (\\n            <View>\\n              <Text style={styles.red}>just red</Text>\\n              <Text style={styles.bigblue}>just bigblue</Text>\\n              <Text style={[styles.bigblue, styles.red]}>bigblue, then red</Text>\\n              <Text style={[styles.red, styles.bigblue]}>red, then bigblue</Text>\\n            </View>\\n          );\\n        }\\n      }\\n\\n      const styles = StyleSheet.create({\\n        bigblue: {\\n          color: 'blue',\\n          fontWeight: 'bold',\\n          fontSize: 30,\\n        },\\n        red: {\\n          color: 'red',\\n        },\\n      });\\n      \\n- 宽高：\\n  - 最简单的给组件设定尺寸的方式就是在样式中指定固定的width和height。React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。\\n      <View>\\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\\n        <View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} />\\n        <View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} />\\n      </View>\\n  - flex弹性宽高：\\n    在组件样式中使用flex可以使其在可利用的空间中动态地扩张或收缩。\\n    \\n      // 试试去掉父View中的`flex: 1`。\\n      // 则父View不再具有尺寸，因此子组件也无法再撑开。\\n      // 然后再用`height: 300`来代替父View的`flex: 1`试试看？\\n      <View style={{flex: 1}}>\\n        <View style={{flex: 1, backgroundColor: 'powderblue'}} />\\n        <View style={{flex: 2, backgroundColor: 'skyblue'}} />\\n        <View style={{flex: 3, backgroundColor: 'steelblue'}} />\\n      </View>\\n      \\n- Flex Direction：在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\\n      // 尝试把`flexDirection`改为`column`看看\\n      <View style={{flex: 1, flexDirection: 'row'}}>\\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\\n        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\\n        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\\n      </View>\\n      \\n- 在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between。\\n      // 尝试把`justifyContent`改为`center`看看\\n      // 尝试把`flexDirection`改为`row`看看\\n      <View style={{\\n        flex: 1,\\n        flexDirection: 'column',\\n        justifyContent: 'space-between',\\n      }}>\\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\\n        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\\n        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\\n      </View>\\n      \\n- align items：在组件的style中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：flex-start、center、flex-end以及stretch。\\n    注意：要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。以下面的代码为例：只有将子元素样式中的width: 50去掉之后，alignItems: 'stretch'才能生效。\\n      \\n      // 尝试把`alignItems`改为`flex-start`看看\\n      // 尝试把`justifyContent`改为`flex-end`看看\\n      // 尝试把`flexDirection`改为`row`看看\\n      <View style={{\\n        flex: 1,\\n        flexDirection: 'column',\\n        justifyContent: 'center',\\n        alignItems: 'center',\\n      }}>\\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\\n        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\\n        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\\n      </View>\\n\\n      布局样式属性:https://reactnative.cn/docs/0.51/layout-props.html\\n\\n- TextInput：\\n      <View style={{padding: 10}}>\\n        <TextInput\\n          style={{height: 40}}\\n          placeholder=\\\"Type here to translate!\\\"\\n          onChangeText={(text) => this.setState({text})}\\n        />\\n        <Text style={{padding: 10, fontSize: 42}}>\\n          {this.state.text.split(' ').map((word) => word && '??').join(' ')}\\n        </Text>\\n      </View>\\n      \\n- ScrollView：\\n  ScrollView是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。ScrollView不仅可以垂直滚动，还能水平滚动（通过horizontal属性来设置）。\\n  \\n       <ScrollView>\\n          <Text style={{fontSize:96}}>Scroll me plz</Text>\\n          <Image source={require('./img/favicon.png')} />\\n          ...\\n        </ScrollView>\\n\\n- FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。\\n  FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。\\n  FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。\\n  \\n      <View style={styles.container}>\\n        <FlatList\\n          data={[\\n            {key: 'Devin'},\\n            {key: 'Jackson'},\\n            {key: 'James'},\\n            {key: 'Joel'},\\n            {key: 'John'},\\n            {key: 'Jillian'},\\n            {key: 'Jimmy'},\\n            {key: 'Julie'},\\n          ]}\\n          renderItem={({item}) => <Text style={styles.item}>{item.key}</Text>}\\n        />\\n      </View>\\n      \\n- SectionList:渲染的是一组需要分组的数据，也许还带有分组标签的\\n      <View style={styles.container}>\\n        <SectionList\\n          sections={[\\n            {title: 'D', data: ['Devin']},\\n            {title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']},\\n          ]}\\n          renderItem={({item}) => <Text style={styles.item}>{item}</Text>}\\n          renderSectionHeader={({section}) => <Text style={styles.sectionHeader}>{section.title}</Text>}\\n        />\\n      </View>\\n    \\n\\n\\n- fetch:\\n\\n      fetch('https://mywebsite.com/endpoint/', {\\n        method: 'POST',\\n        headers: {\\n          'Accept': 'application/json',\\n          'Content-Type': 'application/json',\\n        },\\n        body: JSON.stringify({\\n          firstParam: 'yourValue',\\n          secondParam: 'yourOtherValue',\\n        })\\n      })\\n      .then((response) => response.json())\\n      .then((responseJson) => {\\n        return responseJson.movies;\\n      })\\n      .catch((error) => {\\n        console.error(error);\\n      });\\n      \\n      - 传统表单\\n      fetch('https://mywebsite.com/endpoint/', {\\n        method: 'POST',\\n        headers: {\\n          'Content-Type': 'application/x-www-form-urlencoded',\\n        },\\n        body: 'key1=value1&key2=value2'\\n      })\\n      \\n      \\n      - ES7 写法：\\n        async getMoviesFromApi() {\\n          try {\\n            // 注意这里的await语句，其所在的函数必须有async关键字声明\\n            let response = await fetch('https://facebook.github.io/react-native/movies.json');\\n            let responseJson = await response.json();\\n            return responseJson.movies;\\n          } catch(error) {\\n            console.error(error);\\n          }\\n        }\\n- WebSocket：\\n    \\n    var ws = new WebSocket('ws://host.com/path');\\n\\n    ws.onopen = () => {\\n      // 打开一个连接\\n\\n      ws.send('something'); // 发送一个消息\\n    };\\n\\n    ws.onmessage = (e) => {\\n      // 接收到了一个消息\\n      console.log(e.data);\\n    };\\n\\n    ws.onerror = (e) => {\\n      // 发生了一个错误\\n      console.log(e.message);\\n    };\\n\\n    ws.onclose = (e) => {\\n      // 连接被关闭了\\n      console.log(e.code, e.reason);\\n    };\\n    \\n- 颜色：\\n    '#f0f' (#rgb)\\n    '#f0fc' (#rgba)\\n    '#ff00ff' (#rrggbb)\\n    '#ff00ff00' (#rrggbbaa)\\n    'rgb(255, 255, 255)'\\n    'rgba(255, 255, 255, 1.0)'\\n    'hsl(360, 100%, 100%)'\\n    'hsla(360, 100%, 100%, 1.0)'\\n    'transparent'\\n    'red'\\n    0xff00ff00 (0xrrggbbaa)\\n\\n- react-native-router-flux ： https://github.com/aksonov/react-native-router-flux/blob/HEAD/docs/API.md\\n\\n- 图片：\\n  - 图片文件的查找会和JS模块的查找方式一样。在下面的这个例子里，是哪个组件引用了这个图片，Packager就会去这个组件所在的文件夹下查找my-icon.png。并且，如果你有my-icon.ios.png和my-icon.android.png，Packager就会根据平台而选择不同的文件。\\n\\n    <Image source={require('./my-icon.png')} />\\n\\n  - 你还可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片。比如下面这样的代码结构：\\n\\n    .\\n    ├── button.js\\n    └── img\\n        ├── check@2x.png\\n        └── check@3x.png\\n        \\n   并且button.js里有这样的代码：\\n\\n      <Image source={require('./img/check.png')} />\\n      \\n  - Packager会打包所有的图片并且依据屏幕精度提供对应的资源。譬如说，iPhone 5s会使用check@2x.png，而Nexus 5上则会使用check@3x.png。如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片。\\n\\n  - 注意：为了使新的图片资源机制正常工作，require中的图片名字必须是一个静态字符串（不能使用变量！因为require是在编译时期执行，而非运行时期执行！）。\\n\\n  - 网络图片：很多要在App中显示的图片并不能在编译的时候获得，又或者有时候需要动态载入来减少打包后的二进制文件的大小。这些时候，与静态资源不同的是，你需要手动指定图片的尺寸。同时我们强烈建议你使用https以满足iOS App Transport Security 的要求。\\n      \\n      // 正确\\n      <Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\\n             style={{width: 400, height: 400}} />\\n             \\n      // 错误\\n      <Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />\\n\\n- 可点击的组件：\\n   - 一般来说，你可以使用<a href=\\\"https://reactnative.cn/docs/0.51/touchablehighlight.html\\\">TouchableHighlight</a>来制作按钮或者链接。注意此组件的背景会在用户手指按下时变暗。\\n   - 在Android上还可以使用<a href=\\\"https://reactnative.cn/docs/0.51/touchablenativefeedback.html\\\">TouchableNativeFeedback</a>，它会在用户手指按下时形成类似墨水涟漪的视觉效果。\\n   - <a href=\\\"https://reactnative.cn/docs/0.51/touchableopacity.html\\\">TouchableOpacity</a>会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。\\n   - 如果你想在处理点击事件的同时不显示任何视觉反馈，则需要使用<a href=\\\"https://reactnative.cn/docs/0.51/touchablewithoutfeedback.html\\\">TouchableWithoutFeedback</a>。\\n\\n\\n      <TouchableHighlight onPress={this._onPressButton}>\\n        <Text>Button</Text>\\n      </TouchableHighlight>\\n\\n    - 长按： onLongPress\\n    - 双指缩放：\\n      如果在ScrollView中只放置一个组件，则可以用来实现缩放操作。设置maximumZoomScale和minimumZoomScale属性即可以使用户能够缩放其中的内容。\\n\\n- Animated ：\\n  - Animated库使得开发者可以非常容易地实现各种各样的动画和交互方式，并且具备极高的性能。Animated旨在以声明的形式来定义动画的输入与输出，在其中建立一个可配置的变化函数，然后使用简单的start/stop方法来控制动画按顺序执行。 Animated仅封装了四个可以动画化的组件：View、Text、Image和ScrollView，不过你也可以使用Animated.createAnimatedComponent()来封装你自己的组件。\\n  下面是一个在加载时带有淡入动画效果的视图：\\n  \\n      // FadeInView.js\\n      import React, { Component } from 'react';\\n      import {\\n        Animated,\\n      } from 'react-native';\\n\\n      export default class FadeInView extends Component {\\n        constructor(props) {\\n          super(props);\\n          this.state = {\\n            fadeAnim: new Animated.Value(0),          // 透明度初始值设为0\\n          };\\n        }\\n        componentDidMount() {\\n          Animated.timing(                            // 随时间变化而执行的动画类型\\n            this.state.fadeAnim,                      // 动画中的变量值\\n            {\\n              toValue: 1,                             // 透明度最终变为1，即完全不透明\\n            }\\n          ).start();                                  // 开始执行动画\\n        }\\n        render() {\\n          return (\\n            <Animated.View                            // 可动画化的视图组件\\n              style={{\\n                ...this.props.style,\\n                opacity: this.state.fadeAnim,          // 将透明度指定为动画变量值\\n              }}\\n            >\\n              {this.props.children}\\n            </Animated.View>\\n          );\\n        }\\n      }\\n  \\n\\n      然后你就可以在组件中像使用View那样去使用FadeInView了，比如像下面这样：\\n\\n      render() {\\n        return (\\n          <FadeInView style={{width: 250, height: 50, backgroundColor: 'powderblue'}}>\\n            <Text style={{fontSize: 28, textAlign: 'center', margin: 10}}>Fading in</Text>\\n          </FadeInView>\\n        )\\n      }\\n\\n  - Animated.timing(\\n      this.state.xPosition,\\n      {\\n        toValue: 100,\\n        easing: Easing.back,//稍微倒退\\n        duration: 2000,//持续2s\\n      }                              \\n    ).start();\\n    \\n  - 组合动画：多个动画可以通过parallel（同时执行）、sequence（顺序执行）、stagger和delay来组合使用。它们中的每一个都接受一个要执行的动画数组，并且自动在适当的时候调用start/stop。\\n        \\n        Animated.sequence([            // 首先执行decay动画，结束后同时执行spring和twirl动画\\n          Animated.decay(position, {   // 滑行一段距离后停止\\n            velocity: {x: gestureState.vx, y: gestureState.vy}, // 根据用户的手势设置速度\\n            deceleration: 0.997,\\n          }),\\n          Animated.parallel([          // 在decay之后并行执行：\\n            Animated.spring(position, {\\n              toValue: {x: 0, y: 0}    // 返回到起始点开始\\n            }),\\n            Animated.timing(twirl, {   // 同时开始旋转\\n              toValue: 360,\\n            }),\\n          ]),\\n        ]).start();                    // 执行这一整套动画序列\\n  \\n  - 原生动画驱动：\\n    通过启用原生驱动，我们在启动动画前就把其所有配置信息都发送到原生端，利用原生代码在UI线程执行动画，而不用每一帧都在两端间来回沟通。 如此一来，动画一开始就完全脱离了JS线程，因此此时即便JS线程被卡住，也不会影响到动画了。\\n    \\n        Animated.timing(this.state.animatedValue, {\\n          toValue: 1,\\n          duration: 500,\\n          useNativeDriver: true, // <-- 加上这一行\\n        }).start();\\n        \\n  - LayoutAnimation：\\n    - LayoutAnimation允许你在全局范围内创建和更新动画，这些动画会在下一次渲染或布局周期运行。它常用来更新flexbox布局，因为它可以无需测量或者计算特定属性就能直接产生动画。尤其是当布局变化可能影响到父节点（譬如“查看更多”展开动画既增加父节点的尺寸又会将位于本行之下的所有行向下推动）时，如果不使用LayoutAnimation，可能就需要显式声明组件的坐标，才能使得所有受影响的组件能够同步运行动画。\\n    另外，如果要在Android上使用LayoutAnimation，那么目前还需要在UIManager中启用：\\n      \\n      UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);\\n\\n    - 示例：\\n        import React from 'react';\\n        import {\\n          NativeModules,\\n          LayoutAnimation,\\n          Text,\\n          TouchableOpacity,\\n          StyleSheet,\\n          View,\\n        } from 'react-native';\\n\\n        const { UIManager } = NativeModules;\\n\\n        UIManager.setLayoutAnimationEnabledExperimental &&\\n          UIManager.setLayoutAnimationEnabledExperimental(true);\\n\\n        export default class App extends React.Component {\\n          state = {\\n            w: 100,\\n            h: 100,\\n          };\\n\\n          _onPress = () => {\\n            // Animate the update ，开启动画，将再更新state过程中应用\\n            LayoutAnimation.spring();\\n            this.setState({w: this.state.w + 15, h: this.state.h + 15})\\n          }\\n\\n          render() {\\n            return (\\n              <View style={styles.container}>\\n                <View style={[styles.box, {width: this.state.w, height: this.state.h}]} />\\n                <TouchableOpacity onPress={this._onPress}>\\n                  <View style={styles.button}>\\n                    <Text style={styles.buttonText}>Press me!</Text>\\n                  </View>\\n                </TouchableOpacity>\\n              </View>\\n            );\\n          }\\n        }\\n\\n        const styles = StyleSheet.create({\\n          container: {\\n            flex: 1,\\n            alignItems: 'center',\\n            justifyContent: 'center',\\n          },\\n          box: {\\n            width: 200,\\n            height: 200,\\n            backgroundColor: 'red',\\n          },\\n          button: {\\n            backgroundColor: 'black',\\n            paddingHorizontal: 20,\\n            paddingVertical: 15,\\n            marginTop: 15,\\n          },\\n          buttonText: {\\n            color: '#fff',\\n            fontWeight: 'bold',\\n          },\\n        });\\n  \\n  \\n- 定时器：\\n  - setTimeout, clearTimeout\\n  - setInterval, clearInterval\\n  - setImmediate, clearImmediate\\n  - requestAnimationFrame, cancelAnimationFrame\\n  - requestAnimationFrame(fn)和setTimeout(fn, 0)不同，前者会在每帧刷新之后执行一次，而后者则会尽可能快的执行（在iPhone5S上有可能每秒1000次以上）。\\n\\n  - setImmediate则会在当前JavaScript执行块结束的时候执行，就在将要发送批量响应数据到原生之前。注意如果你在setImmediate的回调函数中又执行了setImmediate，它会紧接着立刻执行，而不会在调用之前等待原生代码。\\n\\n  - Promise的实现就使用了setImmediate来执行异步调用。\\n  \\n  - 务必在卸载组件前清除定时器：\\n    我们发现很多React Native应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被卸载（unmount）之后，计时器却仍然在运行。要解决这个问题，只需铭记在unmount组件时清除（clearTimeout/clearInterval）所有用到的定时器即可：\\n    \\n        import React,{\\n          Component\\n        } from 'react';\\n\\n        export default class Hello extends Component {\\n          componentDidMount() {\\n            this.timer = setTimeout(\\n              () => { console.log('把一个定时器的引用挂在this上'); },\\n              500\\n            );\\n          }\\n          componentWillUnmount() {\\n            // 请注意Un\\\"m\\\"ount的m是小写\\n\\n            // 如果存在this.timer，则使用clearTimeout清空。\\n            // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear\\n            this.timer && clearTimeout(this.timer);\\n          }\\n        };\\n  \\n  \\n- InteractionManager：\\n  - 原生应用感觉如此流畅的一个重要原因就是在互动和动画的过程中避免繁重的操作。在React Native里，我们目前受到限制，因为我们只有一个JavaScript执行线程。不过你可以用InteractionManager来确保在执行繁重工作之前所有的交互和动画都已经处理完毕。\\n  - 应用可以通过以下代码来安排一个任务，使其在交互结束之后执行：\\n    \\n      InteractionManager.runAfterInteractions(() => {\\n         // ...需要长时间同步执行的任务...\\n      });\\n    \\n  - 我们来把它和之前的几个任务安排方法对比一下：\\n\\n      requestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码\\n      setImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。\\n      runAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。\\n  \\n      触摸处理系统会把一个或多个进行中的触摸操作认定为'交互'，并且会将runAfterInteractions()的回调函数延迟执行，直到所有的触摸操作都结束或取消了。\\n  \\n  - InteractionManager还允许应用注册动画，在动画开始时创建一个交互“句柄”，然后在结束的时候清除它。\\n\\n      var handle = InteractionManager.createInteractionHandle();\\n      // 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)\\n      // 在动画完成之后\\n      InteractionManager.clearInteractionHandle(handle);\\n      // 在所有句柄都清除之后，现在开始依序执行队列中的任务\\n  \\n  \\n  \\n- 修改app名称和图标：\\n    https://blog.csdn.net/ljfphp/article/details/79273168\\n  \\n  \\n  \\n  \\n- 无法删除目录：rd /s build\\n  \\n- 使用Java编写原生module：\\n  - module继承ReactContextBaseJavaModule类\\n  - package实现ReactPackage接口\\n  - MainApplication注册包getPackages\\n  \\n- 关于调试找不到source：使用npm找不到源码，使用yarn start可以找到\\n  \\n- react-native调试Java代码：\\n  - 先通过react-native run-android安装app\\n  - 打开react-native 的node服务，yarn start\\n  - 在AS中直接点击debug\\n    - 出现错误：This version of Android Studio is incompatible with the Gradle Plugin used.\\n    - 解决：https://blog.csdn.net/guim_007/article/details/72982660\\n      file-> setting ->Build,Execution,Deployment -> Instant Run -> 取消所有的勾选, 再clean一下project\\n    \\n  \\n- 抽屉菜单：https://blog.csdn.net/github_33304260/article/details/55517995  \\n\\n- react-tools:react-devtools\\n  \\n- 使用抽屉做页面跳转\\n\\n- 打包apk：\\n  - 生成签名：\\n    keytool -genkey -v -keystore my-release-key.keystore -alias xuchg-key-alias -keyalg RSA -keysize 2048 -validity 10000\\n  - 使用 \\\"keytool -importkeystore -srckeystore my-release-key.keystore -destkeystore my-release-key.keystore -deststoretype pkcs12\\\" 迁移到行业标准格式 PKCS12。\\n  - gradlew assembleRelease\\n  \\n# 短信助手\\n- 背景：笔者有多个手机卡，所以就可能有多个手机，但是不可能都一直带在身边，但又要接收到手机卡的短信。网上一些类似的APP，但笔者觉得有些并不踏实，有些会把信息存储在未知云端，所以手撸一个简单实用的短信助手。\\n- 功能：监听短信接收，并将短信已邮件的形式发送到设置的邮箱中。发送邮箱和接收邮箱全部由本人设置，全部操作只有发送邮件会请求网络。\\n- 引用和RN相关版本：\\n  - react-native：0.55.2\\n  - react：16.3.1\\n  - react-native-elements：0.19.1  UI\\n  - react-native-vector-icons：4.6.0\\n  - react-native-simple-store：1.2.0 存储\\n  - react-native-router-flux：3.39.2 路由，<a href=\\\"https://www.npmjs.com/package/react-native-router-flux#v4-features\\\">V4</a>版本基于react-navigation实现\\n  - alt:0.18.6 状态管理\\n  - android-mail:1.5.5/android-activation:1.5.5  发送邮件\\n  \\n\"},\"children\":[{\"data\":{\"id\":\"c17z7lxmdu00\",\"created\":1583926859385,\"text\":\"会计\",\"layout_right_offset\":{\"x\":2,\"y\":6}},\"children\":[]},{\"data\":{\"id\":\"c17z7qb8a9c0\",\"created\":1583926868915,\"text\":\"safd\",\"expandState\":\"expand\"},\"children\":[{\"data\":{\"id\":\"c17z7xo8vvc0\",\"created\":1583926884939,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7xqr3vs0\",\"created\":1583926885091,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7xtbxg80\",\"created\":1583926885247,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7xvnvx40\",\"created\":1583926885388,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7xy6gdc0\",\"created\":1583926885540,\"text\":\"会计\",\"layout_right_offset\":{\"x\":10,\"y\":8}},\"children\":[{\"data\":{\"id\":\"c17z85qxli00\",\"created\":1583926902516,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z86ky3bc0\",\"created\":1583926904331,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z86ox7mo0\",\"created\":1583926904571,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z86rbf6o0\",\"created\":1583926904716,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z86tthsg0\",\"created\":1583926904867,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z86wi2mg0\",\"created\":1583926905029,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z86yzntc0\",\"created\":1583926905180,\"text\":\"会计\"},\"children\":[]}]},{\"data\":{\"id\":\"c17z7y0opxc0\",\"created\":1583926885691,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7y338ts0\",\"created\":1583926885837,\"text\":\"会计\"},\"children\":[]}]},{\"data\":{\"id\":\"c17z7uyd0a80\",\"created\":1583926879021,\"text\":\"会计\",\"expandState\":\"collapse\"},\"children\":[{\"data\":{\"id\":\"c17z7vv6llc0\",\"created\":1583926881005,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7wglqcw0\",\"created\":1583926882300,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7wtyguo0\",\"created\":1583926883108,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7x1dgns0\",\"created\":1583926883556,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7x4xrl40\",\"created\":1583926883772,\"text\":\"会计\"},\"children\":[]},{\"data\":{\"id\":\"c17z7x7zhp40\",\"created\":1583926883956,\"text\":\"会计\"},\"children\":[]}]}]},\"template\":\"right\",\"theme\":\"fresh-blue\",\"version\":\"1.4.43\"}",
    "edit": false
  }
}